---
title: "btt-discrete-time"
output: html_document
date: "2024-06-06"
---

## Load data and necessary libraries
## Dataset can be constructed from the heart_pipeline_final.Rmd file
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Molly:
load("C:/Users/mhwhi/Downloads/heart_post_policy (8).RData")
df_cand_thor <- haven::read_sas('C:/Users/mhwhi/Downloads/pubsaf2403/cand_thor.sas7bdat')

# Grace:
# load("heart_post_policy.RData")
# curr_data_release = "//srtr-fs-p01/SAF/External/Pub_SAF/saf2403_Q1/pubsaf2403"
# df_cand_thor <- haven::read_sas(file.path(curr_data_release,'cand_thor.sas7bdat'))

library(renv)
library(dplyr)
library(tidyr)
library(lubridate)
library(table1)
library(purrr)

# change this variable to customize inclusion criteria - see heart_pipeline_final.rmd
censor_date_end = mdy("12-31-2023")



# Retain listing date, transplant date for waiting time calculations
df = df %>% mutate(can_listing_dt = if_else(grepl("CAN_LISTING_DT", unique_event), unique_date, NA),
                   transplant_date = if_else(grepl("REC_TX_DT", unique_event), unique_date, NA)) %>% fill(can_listing_dt, transplant_date, .direction = "downup")


df = df %>%
  group_by(PX_ID, status) %>%  # Assuming PX_ID is the patient identifier
  mutate(
    status_start = as.Date(first(unique_date))
  ) %>% mutate(
    status_start_1 = if_else(status == 1, status_start, NA),
    status_start_2 = if_else(status == 2, status_start, NA),
    status_start_3 = if_else(status == 3, status_start, NA),
    status_start_4 = if_else(status == 4, status_start, NA),
    status_start_5 = if_else(status == 5, status_start, NA),
    status_start_6 = if_else(status == 6, status_start, NA)
  ) %>%
  ungroup()

```

## Censor candidates past December 31st, 2023
```{r}
df = df  %>% 
  filter(unique_date <= censor_date_end) %>% 
  group_by(PX_ID) %>%
  mutate(
    need_to_censor = row_number() == n() & t_stop - t_start >  censor_date_end - as.Date(unique_date),
    t_stop = ifelse(need_to_censor, t_start + censor_date_end - as.Date(unique_date), t_stop),
    outcome = ifelse(need_to_censor, 0, outcome)
  )
table(df$t_stop >= df$t_start)

# some numbers
dim(table(df$PX_ID)) # 24516
table(df$transplant) # 16963
table(df$outcome) # 4045 - includes posttx
df %>% mutate(any_tx=any(transplant==1)) %>% ungroup() %>% filter(outcome==1,!any_tx) %>% nrow() # 1926 pretx deaths
```

## Identify candidates who were delisted
## Determine time to death / censor for these candidates
```{r}
 # only one person with rows/death after removal
df %>% filter(cumsum(cumsum(grepl("CAN_REM_DT", unique_event)))>1) %>% select(PX_ID,unique_event,outcome)

# create delisting indicator
df = df %>% mutate(
  delisting = ifelse(grepl("CAN_REM_DT", unique_event) & !grepl("REC_TX_DT", unique_event), 1, 0)
)

# similar to row from transplant to death/censoring, make one row from delisting to death
df = df %>% group_by(PX_ID) %>%
  mutate(delisting = cumsum(cumsum(delisting)),
         t_stop = ifelse(delisting == 1, last(t_stop), t_stop),
         outcome = ifelse(delisting == 1, last(outcome), outcome)) %>%
  filter(delisting <= 1)

# make time from delisting to death/censor
df = df %>% mutate(
  time_until_death_after_delisting = ifelse(delisting == 1 & outcome == 1, t_stop - t_start, NA),
  time_until_censor_after_delisting = ifelse(delisting == 1 & outcome == 0, censor_date_end - as.Date(unique_date), NA)) %>% group_by(PX_ID) %>% fill(time_until_death_after_delisting, time_until_censor_after_delisting, .direction = "up")

# including posttx deaths in time_until_death_after_delisting? no
df %>% filter(transplant==1,!is.na(time_until_death_after_delisting)) %>% nrow()

# censoring anyone who dies? no
df %>% filter(outcome==1,!is.na(time_until_censor_after_delisting)) %>% nrow()

# count transplant, death, delisting
df %>% ungroup() %>% count(transplant,delisting,outcome)

```


## Define short term mcs ever variables
```{r}

df <- df %>%
  group_by(PX_ID) %>%
  
  mutate(ECMO_ever = case_when(ECMO == '1' ~ '1', TRUE ~ NA_character_),
         temp_surg_ever = case_when(temp_surg_LVAD == '1' ~ '1', TRUE ~ NA_character_),
         BiVAD_no_discharge_ever = case_when(BiVAD_no_discharge == '1' ~ '1', TRUE ~ NA_character_)) %>%
  
  fill(ECMO_ever, .direction = 'down') %>%
  fill(temp_surg_ever, .direction = 'down') %>%
  fill(BiVAD_no_discharge_ever, .direction = 'down') %>%

  mutate(ECMO_ever = case_when(is.na(ECMO_ever) ~ '0', TRUE ~ ECMO_ever),
         temp_surg_ever = case_when(is.na(temp_surg_ever) ~ '0', TRUE ~ temp_surg_ever),
         BiVAD_no_discharge_ever = case_when(is.na(BiVAD_no_discharge_ever) ~ '0', TRUE ~ BiVAD_no_discharge_ever))


```

## Discrete time data construction
```{r}
# create tx dataset
# remove rows at time of transplant, removal
df_tx = df %>% filter(transplant == 1 | (CAN_REM_CD == 4 & grepl("CAN_REM_DT",unique_event)))
df = df %>% filter(cumsum(grepl("CAN_REM_DT", unique_event))<1 |
                     n()==1)

# count up transplants, deaths
dim(table(df$PX_ID)) # 24516
nrow(df_tx) # 16963
df %>% filter(!is.na(time_until_death_after_delisting) | outcome==1) %>% distinct(PX_ID) %>% nrow() # 1928 - two extra bc of posttx deaths (outcome=1 then transplant=1)

# look at people with t_start = t_stop
df %>% filter(t_start==t_stop) %>%
  select(PX_ID,unique_event,unique_date,t_start,t_stop,death_time,outcome,transplant)
df %>% filter(t_start==t_stop,n()!=1) %>%
  select(PX_ID,unique_event,unique_date,t_start,t_stop,death_time,outcome,transplant)

# recode t_stop as 1 if t_stop=0
## otherwise, remove when t_start=t_stop
df = df %>%
  mutate(t_stop=ifelse(t_stop==0,1,t_stop)) %>%
  filter(t_start!=t_stop)
dim(table(df$PX_ID)) # 24516

# define period to group observations that occur within the same week
# take first observation within each week
# duplicate each observation based on how many days there are until the next period
  ## duplication causes some people to have outcome=1 multiple times, if the interval ending in death lasted >1 week
# define interval_start, interval_stop as the 7 day periods

df_final = df %>% mutate(
  period = ceiling(t_stop/7)
) %>% group_by(PX_ID, period) %>% 
  # make outcome=1 for entire week if outcome=1
  mutate(outcome = ifelse(sum(outcome)>0,1,outcome)) %>%
  # taking the first row per week
  filter(row_number() == 1) %>% 
  mutate(
    t_start = ceiling(t_start/7)*7,
    t_stop = ceiling(t_stop/7)*7, 
    duplicates = (t_stop - t_start)/7
  ) %>% ungroup() %>% uncount(duplicates) %>%
  group_by(PX_ID) %>%
  mutate(interval_start = seq(0, max(t_stop) - 7, by = 7),
                             interval_stop = interval_start + 7) %>%
  ungroup()
df_final %>% filter(!is.na(time_until_death_after_delisting) | outcome==1) %>% distinct(PX_ID) %>% nrow() # 1928 - two extra bc of posttx deaths (outcome=1 then transplant=1)

df_final

```
# Missingness before out of range fix
```{r}
table1(~  albumin + bilirubin + creatinine + sodium + BNP + cardiac_output + diastolicBP + systolicBP + PCWP + PASP + PADP + central_venous_pressure +
    factor(durable_LVAD) + factor(ECMO_ever), data=df_final)

```


```{r}
#out of range value flag
df_final = df_final %>% mutate(
  out_of_range_flag = case_when(
    sodium < 100 | sodium > 200 ~ 1,
    BNP_NT_Pro == 0 & BNP > 20000 ~ 1,
    BNP_NT_Pro == 1 & BNP > 40000 ~ 1,
    bilirubin > 50 ~ 1,
    albumin < 0.5 | albumin > 9.9 ~ 1,
    cardiac_output < 0.2 | cardiac_output > 15 ~ 1,
    diastolicBP > 110 ~ 1,
    systolicBP < 10 | systolicBP > 300 ~ 1,
    PCWP > 100 ~ 1,
    PASP < 10 | PASP > 120 ~ 1,
    PADP > 110 ~ 1,
    central_venous_pressure > 110 ~ 1,
    creatinine < 0.1 | creatinine > 40 ~ 1,
    TRUE ~ 0)
)

#set out of range values to missing
df_final = df_final %>% mutate(
  sodium = ifelse(sodium < 100 | sodium > 200, NA, sodium),
  BNP = case_when(
    BNP_NT_Pro == 0 & BNP > 20000 ~ NA,
    BNP_NT_Pro == 1 & BNP > 40000 ~ NA,
    TRUE ~ BNP
  ),
  bilirubin = ifelse(bilirubin > 50, NA, bilirubin),
  albumin = ifelse(albumin < 0.5 | albumin > 9.9, NA, albumin),
  cardiac_output = ifelse(cardiac_output < 0.2 | cardiac_output > 15, NA, cardiac_output),
  diastolicBP = ifelse(diastolicBP > 110, NA, diastolicBP),
  systolicBP = ifelse(systolicBP < 10 | systolicBP > 300, NA, systolicBP),
  PCWP = ifelse(PCWP > 100, NA, PCWP),
  PASP = ifelse(PASP < 10 | PASP > 120, NA, PASP),
  PADP = ifelse(PADP > 110, NA, PADP),
  central_venous_pressure = ifelse(central_venous_pressure > 110, NA, central_venous_pressure),
  creatinine = ifelse(creatinine < 0.1 | creatinine > 40, NA, creatinine)
)

```

```{r}
#add dates back into dataframe
df_final = df_final %>% mutate(
  last_wait_date = pmax(last_active_date, last_inactive_date, na.rm = T)
) 
df_final = df_final %>% 
  mutate(
    current_date = as.Date(can_listing_dt) + interval_start
      ) %>% mutate(
        current_date_end = current_date + pmin(last_wait_date - current_date, 7, na.rm = T)
      )


```


# Data summary before imputation
```{r}
#reduce data to cohort, create train/testing split
table_data = df_final %>% 
  filter(current_date >= "2019-01-01") %>% mutate(
  train_test_split = ifelse(current_date_end < "2023-01-01", "train", "test")
) %>% mutate(
  train_test_split = as.factor(train_test_split)
)


table1(~  albumin + bilirubin + creatinine + sodium + BNP + cardiac_output + diastolicBP + systolicBP + PCWP + PASP + PADP + central_venous_pressure  + out_of_range_flag + 
    factor(durable_LVAD) + factor(ECMO_ever) | train_test_split, data=table_data) # very low percent missing except w/ BNP
summary(df_final$BNP[df_final$BNP_NT_Pro %in% 0]) # should be between 0 and 20000
summary(df_final$BNP[df_final$BNP_NT_Pro %in% 1]) # should be between 0 and 40000


```



## Set transplant = 1 for PX_ID in transplant list, at their last observation on the waitlist
```{r}
tx_patients = unique(df_tx$PX_ID)

df_final = df_final %>% group_by(PX_ID) %>%
  mutate(
  transplant = ifelse(row_number() == n() & PX_ID %in% tx_patients, 1, 0)
) %>% select(-c(t_start, t_stop, period, unique_event, unique_date)) %>% 
  relocate(interval_start, interval_stop, .after=CAN_LISTING_CTR_CD)

df_final %>% filter(PX_ID == 1310477) %>% select(PX_ID, transplant)
```


# Body surface area calculation
```{r}
# select necessary cand thor variables
df_cand_thor <- df_cand_thor %>% select(PX_ID, CAN_GENDER, CAN_RACE, CAN_HGT_CM, CAN_WGT_KG, CAN_ECMO)

# impute missing height and weights
df_cand_thor$CAN_HGT_CM[is.na(df_cand_thor$CAN_HGT_CM)] <-median(df_cand_thor$CAN_HGT_CM, na.rm=T)
df_cand_thor$CAN_WGT_KG[is.na(df_cand_thor$CAN_WGT_KG)] <-median(df_cand_thor$CAN_WGT_KG, na.rm=T)

# define body surface area, merge with discrete time data
df_cand_thor <- df_cand_thor %>%
  mutate(bsa = 0.007184 * (CAN_HGT_CM ^ 0.725) * (CAN_WGT_KG ^ 0.425)) 
df_cand_thor <- df_cand_thor[!duplicated(df_cand_thor), ]
df_final <- merge(df_final, df_cand_thor, by='PX_ID', all.x=T, all.y=F)


```



## Fill missing arterial lactate, LDH, Hemoglobin, BNP, sodium, albumin, bilirubin, creatinine
```{r}
# fill missing arterial lactate, LDH, Hemoglobin, BNP, sodium, albumin, bilirubin, creatinine
df_final <- df_final %>%
  mutate(
    arterial_lactate = ifelse(is.na(arterial_lactate), 1, arterial_lactate),
    LDH = ifelse(is.na(LDH), 220, LDH),
    HemoHemoglobin = case_when(
      is.na(HemoHemoglobin) & CAN_GENDER == 'M' ~ 14.9,
      is.na(HemoHemoglobin) & CAN_GENDER == 'F' ~ 13.3,
      TRUE ~ HemoHemoglobin
    ),
    BNP_NT_Pro = case_when(
      is.na(BNP_NT_Pro) ~ 0,
      TRUE ~ BNP_NT_Pro
    ),
    BNP = case_when(
      is.na(BNP) & BNP_NT_Pro == '0' ~ median(BNP[BNP_NT_Pro == '0'], na.rm = TRUE),
      is.na(BNP) & BNP_NT_Pro == '1' ~ median(BNP[BNP_NT_Pro == '1'], na.rm = TRUE),
      TRUE ~ BNP
    ),
    sodium = ifelse(is.na(sodium), median(sodium, na.rm = TRUE), sodium),
    albumin = ifelse(is.na(albumin), median(albumin, na.rm = TRUE), albumin),
    bilirubin = ifelse(is.na(bilirubin), median(bilirubin, na.rm = TRUE), bilirubin),
    creatinine = ifelse(is.na(creatinine), median(creatinine, na.rm = TRUE), creatinine)
  )
  

```

## Fill missing cardiac_output, central_venous_pressure, PASP, PADP, PCWP, systolicBP, diastolicBP, resting_HR
```{r}
df_final <- df_final %>%
  ungroup() %>%
  mutate(
    cardiac_output = case_when(
      is.na(cardiac_output) & durable_LVAD == '1' ~ 2.5 * bsa,
      is.na(cardiac_output) & durable_LVAD != '1' ~ 2.2 * bsa,
      TRUE ~ cardiac_output
    ), 
    central_venous_pressure = case_when(
      is.na(central_venous_pressure) & durable_LVAD == '1' ~ 10,
      is.na(central_venous_pressure) & durable_LVAD != '1' ~ 12,
      TRUE ~ central_venous_pressure
    ),
    PASP = case_when(
      is.na(PASP) & durable_LVAD == '1' ~ 35,
      is.na(PASP) & durable_LVAD != '1' ~ 38,
      TRUE ~ PASP
    ),
    PADP = case_when(
      is.na(PADP) & durable_LVAD == '1' ~ 15,
      is.na(PADP) & durable_LVAD != '1' ~ 18,
      TRUE ~ PADP
    ),
    PCWP = case_when(
      is.na(PCWP) & durable_LVAD == '1' ~ 15,
      is.na(PCWP) & durable_LVAD != '1' ~ 18,
      TRUE ~ PCWP
    ),
    systolicBP = case_when(
      is.na(systolicBP) & durable_LVAD == '1' ~ 100,
      is.na(systolicBP) & durable_LVAD != '1' ~ 110,
      TRUE ~ systolicBP
    ),
    diastolicBP = ifelse(is.na(diastolicBP), 80, diastolicBP),
    resting_HR = ifelse(is.na(resting_HR), 8.5, resting_HR)
  )
```



## Calculate eGFR, define short mcs ever
```{r}
df_final <- df_final %>%
  mutate(eGFR = case_when(
    CAN_GENDER == 'F' & !is.na(creatinine) ~ 142 * (pmin((creatinine / 0.7), 1)^(-0.241)) *
      (pmax((creatinine / 0.7), 1)^(-1.2)) * 0.9938^(age_at_listing) * 1.012,
    
    CAN_GENDER == 'M' & !is.na(creatinine) ~ 142 * (pmin((creatinine / 0.9), 1)^(-0.302)) *
      (pmax((creatinine / 0.9), 1)^(-1.2)) * 0.9938^(age_at_listing)),
    short_MCS_ever_old = 
         case_when(ECMO_ever == '1' | temp_surg_ever == '1' | BiVAD_no_discharge_ever == '1' ~ 1,
           TRUE ~ 0),
    short_MCS_ever = 
         case_when(ECMO_ever == '1' | temp_surg_ever == '1' | BiVAD_no_discharge_ever == '1' | CAN_ECMO %in% 1 ~ 1,
           TRUE ~ 0))
with(df_final,table(short_MCS_ever_old,short_MCS_ever,useNA="ifany"))

```
## Define hemodynamics, impute missing values
```{r}
# define hemodynamics, impute missing values
df_final <- df_final %>%
  mutate(
    cpo = (1/541) * cardiac_output * (((2/3)*systolicBP) + ((1/3)*diastolicBP)),
    api = (systolicBP - diastolicBP) / PCWP,
    papi = (PASP - PADP) / central_venous_pressure) %>%
  
  mutate(cpo = as.numeric(cpo),
         api = as.numeric(api),
         papi = as.numeric(papi)) %>%
  mutate(api = ifelse(PCWP == 0, 1, api),
         papi = case_when(
            central_venous_pressure == 0 ~ 1,
            papi < 1 & !is.na(papi) ~ 1,
            TRUE ~ papi
    ))
 


```


```{r}
calculate_wait_times <- function(status_vector, current_date, status_start_1, status_start_2, status_start_3, status_start_4, status_start_5, status_start_6) {
  n <- length(status_vector)
  
  # Convert to character if not already
  status_vector <- as.character(status_vector)
  
  # Initialize wait time vectors
  wait_1 <- numeric(n)
  wait_2 <- numeric(n)
  wait_3 <- numeric(n)
  wait_4 <- numeric(n)
  wait_5 <- numeric(n)
  wait_6 <- numeric(n)
  
  # Flags to check if first time the status is encountered
  first_time_1 <- TRUE
  first_time_2 <- TRUE
  first_time_3 <- TRUE
  first_time_4 <- TRUE
  first_time_5 <- TRUE
  first_time_6 <- TRUE
  
  # Initialize cumulative wait times
  cum_wait_1 <- 0
  cum_wait_2 <- 0
  cum_wait_3 <- 0
  cum_wait_4 <- 0
  cum_wait_5 <- 0
  cum_wait_6 <- 0
  
  # Loop through each time point
  for (i in 1:n) {
    current_status <- status_vector[i]
    
    if (is.na(current_status) || current_status == "inactive") {
      # Freeze wait times during inactive period, no accrual but keep the last values
      wait_1[i] <- cum_wait_1
      wait_2[i] <- cum_wait_2
      wait_3[i] <- cum_wait_3
      wait_4[i] <- cum_wait_4
      wait_5[i] <- cum_wait_5
      wait_6[i] <- cum_wait_6  # Ensure that the last value of wait_6 is retained
    } else {
      # Increment wait times only when the current status allows
      
      # Status 1 logic
      if (current_status == "1") {
        if (first_time_1) {
          cum_wait_1 <- as.numeric(current_date[i] - status_start_1[i])
          first_time_1 <- FALSE
        } else {
          cum_wait_1 <- cum_wait_1 + 7
        }
      }
      
      # Status 2 logic
      if (current_status <= "2") {
        if (first_time_2) {
          cum_wait_2 <- as.numeric(current_date[i] - status_start_2[i])
          first_time_2 <- FALSE
        } else {
          cum_wait_2 <- cum_wait_2 + 7
        }
      }
      
      # Status 3 logic
      if (current_status <= "3") {
        if (first_time_3) {
          cum_wait_3 <- as.numeric(current_date[i] - status_start_3[i])
          first_time_3 <- FALSE
        } else {
          cum_wait_3 <- cum_wait_3 + 7
        }
      }
      
      # Status 4 logic
      if (current_status <= "4") {
        if (first_time_4) {
          cum_wait_4 <- as.numeric(current_date[i] - status_start_4[i])
          first_time_4 <- FALSE
        } else {
          cum_wait_4 <- cum_wait_4 + 7
        }
      }
      
      # Status 5 logic
      if (current_status <= "5") {
        if (first_time_5) {
          cum_wait_5 <- as.numeric(current_date[i] - status_start_5[i])
          first_time_5 <- FALSE
        } else {
          cum_wait_5 <- cum_wait_5 + 7
        }
      }
      
      # Status 6 logic
      if (current_status == "6") {  # Only accrue when status is exactly 6
        if (first_time_6) {
          cum_wait_6 <- as.numeric(current_date[i] - status_start_6[i])
          first_time_6 <- FALSE
        } else {
          cum_wait_6 <- cum_wait_6 + 7
        }
      }
      
      # Assign cumulative wait times to the wait vectors
      wait_1[i] <- cum_wait_1
      wait_2[i] <- cum_wait_2
      wait_3[i] <- cum_wait_3
      wait_4[i] <- cum_wait_4
      wait_5[i] <- cum_wait_5
      wait_6[i] <- cum_wait_6
    }
  }
  
  # Return the wait time vectors as a data frame
  data.frame(wait_1, wait_2, wait_3, wait_4, wait_5, wait_6)
}



df_final <- df_final %>%
  group_by(PX_ID) %>%
  do({
    wait_times <- calculate_wait_times(
      status_vector = as.character(.$status),
      current_date = .$current_date,
      status_start_1 = .$status_start_1,
      status_start_2 = .$status_start_2,
      status_start_3 = .$status_start_3,
      status_start_4 = .$status_start_4,
      status_start_5 = .$status_start_5,
      status_start_6 = .$status_start_6
    )
    cbind(., wait_times)  # Combine the original dataframe with the new wait times
  }) %>%
  ungroup()  # Ungroup after processing

# check that wait time freezes when inactive
df_final  %>% select(PX_ID, status, interval_start, interval_stop, wait_1, wait_2, wait_3, wait_4, wait_5, wait_6)
```



# Save discrete time data
```{r}
# check numbers
dim(table(df_final$PX_ID)) # 24516
table(df_final$transplant) # 16963
df_final %>% filter(outcome==1 | !is.na(time_until_death_after_delisting)) %>% distinct(PX_ID) %>% nrow() # 1928
table(df_final$interval_start < df_final$interval_stop)
save("df_final", file =  "discrete_final_data.RData")
```










